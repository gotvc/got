# Why Got?

Got is general-purpose filesystem version control for power users.
Millions of developers use version control software (and Git specifically) every day.
Learning how to use Git has essentially become a right of passage, and it's basically impossible to meaningfully contribute to a software project without knowing how to use Git.

Version control is clearly a fundamentally good idea if it is what allows people to do complicated creative work, with other people, across multiple devices, across multiple timezones, sanely.
However version control is largely limited to software development, and there isn't anything as popular or dependable as Git for everything else.

Anyone who knows how to use Git should, in theory, have solved all their problems associated with versioning, syncing, encrypting, and replicatin of all their data.
But this is not the case.
Even when I talk to experienced developers--powerful wizards, they have settled for a workflow where everything is in plaintext in the cloud, or they don't have offsite backups, or only some of their data is in version control, or they have multiple repositories, or they wrestle with LFS.
All less than ideal, and problems that Got was created to solve.

## Why not Git
Git is not suitable for general-purpose version control for a few reasons.
This section explains how Got was designed to improve on Git.

### 1. Git is not Encrypted
Tax returns, medical records, and other sensitive data that you need to keep track of should not be sent to a remote server unencrypted.
This data is some of the most important in terms of the amount time that not having it organized can waste.
Having it available is convenient, but it also creates liabilities if other humans or robots can read it.
Plaintext data in the cloud can be used to steal your identity, sell you ads, or steal digital assets like cryptocurrency.
Any "all your data" solution needs to be able to handle these files, or they will require yet another separate workflow.

Data is safest when it exists in multiple places far away from one another.
In order to store data remotely, you need to send it off of a device that you are currently sitting at, and on to a device that you don't physically control.
That requires encryption in order to be secure.
Data should never exist in plaintext on a device unless a human is physically present and accessing the data.
It should be stored as ciphertext and downloaded onto the device currently in use.

### 2. Git is for small files and small directories
Software source code is all text organized into many small files.
This is a good fit for Git's data structure, and this assumption allows Git's format to be simple, which is a huge benefit.

However it means that you can't just use Git to store a home video.
Let's consider a 1GB home video shot on an iPhone.
You can literally execute the Git command to add the video, Git won't blow up, but it will create problems.
Firstly it will take a little while to import.
Git identifies files by the SHA1 of the entire file, that means the entire file has to be read and digested serially.
That's slow.
Got imports happen in mostly in parallel, with a small amount of serial computation taking place at the end.
Copying data in and out of Got scales with the number of cores on the machine.

Secondly, for the same reason, it will take a long time to download and upload, and if interrupted, progress will be lost.
In order to verify the integrity of a blob, Git & Got must check its hash.
If the value is large, then it takes a while to hash, and the work of downloading it cannot be checkpointed until after the hash has been verified.
When a file can be split into many smaller blobs, each blob can be verified in a smaller amount of time, and if there is an interruption, a smaller amount of work would be lost.

## What about Git Remote Helpers and LFS?
These things are not Git, they are separate software, and they don't compose together well.
A git remote helper only deals with normal Git objects like Commits, Trees, and Blobs.
Remote helpers for encryption do exist, but they don't automatically encrypt the LFS data, which is still stored out of band.
Git LFS data does not automatically inherit the properties that a remote helper gives.
Git Large File Storage (LFS) requires an HTTP based, out-of-band workflow.
And if you want to reason about where that data is and how to move it around, then you need to use the LFS tools.
It also requires setting up a separate piece of software on the server side to accept the LFS data.
LFS also requires another solution for encryption.

## The Vision
Replace cloud drives provided by Google, Apple, and Dropbox with a single, secure, privacy preserving solution modeled after industry standard tools.

All your files should be everywhere you are, you should never worry about accidentally deleting anything.

Backups should be as easy as `got push`.

Got Spaces are just Blobcache Volumes.
Anyone can host Blobcache with `docker run ghcr.io/blobcache/blobcache:latest`, creating a universal backend for E2E encrypted storage.

Licensed under the GPL, so you'll always have the source code, and you know it does what it says.
