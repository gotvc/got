# Got for the Git Familiar

This article assumes knowledge of Git.
If you know what Git is, then Got is the same kind of thing, except it's designed from the ground up to: 
1. Store and version large files and directories
2. Encrypt all data, so that it can it be stored securely on remote devices.
Got is not designed to be used primarily for software development, just use Git for that.
It is designed to be used by power users instead of something like Google Drive or Dropbox.
It also probably works well as a backup or syncing solution, if precise versioning across the entire filesystem is important.

Git is excellent version control software.
For its minimal complexity, its core design is close to the pareto frontier.
All the formats are straightforward and easy to parse; lots of spaces, newlines, and tasteful use of NULL bytes and inline binary.
Most criticism of Git is instead directed towards its user interface, which was initially poor.
Although it has been slowly improving, it is held back by backwards compatibility.
Many of Git's models were worth copying almost exactly, but how they are presented to the user was usually worth improving.

## Similar Models

Got's model of version control is heavily inspired by Git.
And the name can be generated by incementing the vowel in Git.
There are many concepts taken, or adapted from Git, their provenances are listed below.

``` 
Git                  | Got     
---------------------------------------------
Repository           | Repository (Repo)
Worktrees            | Working Copies (WC)
Commits              | Snapshots (Snaps)
Refs, Branches, Tags | Bookmarks (Marks)
Blobs, Trees         | Filesystems
Remotes              | Spaces
```

## Refs, Branches, Tags vs. Marks, Snapshots
In Git, there is a very general idea of a reference, which includes hashes of objects, names for hashes of objects, and names of names.
Git's `HEAD` (taken from the common name for the double-pointer used in linked lists) is therefore a name of a name of a hash of an object, or a ref of a ref of a ref.

In Got, Marks are named pointers to Snapshots.
Marks have names which are unique for the Space that contains them.
Each Repo has a default Space with locally saved content.
Each WC has a HEAD configuration parameter, which contains the name of a mark in the local namespace.
That is the only place in Got where that level of indirection to Snapshots is needed, and it is therefore implemented as a one-off in the WC.

## Remotes vs. Spaces
In both Git and Got these concepts are containers for refs.
In both, sync operations can be performed between two instances.
Only Got allows syncing operations to be performed between two external Spaces, without requiring that the data be persisted locally.
Got also considers the local set of marks to be part of it's own Space, identified by the empty string.

Spaces in Got are always encrypted.
The encryption key is stored in the Repo's configuration.
This means that you can use a remote Blobcache to host a Got space, and unless you reveal the encryption key, the server has no way of reading any of the data, including Mark names.

## Git vs. Got Identities
I know that Git makes it possible to sign things with some other piece of software.
I only know that exists because GitHub tells me about it.
I don't know what Git uses to sign the Commits (or the Tags?), other than that it may have some of the letters P, G, S, and or H in its name.

Got generates private signing keys automatically and stores them in each Repo.
An identifier, derived from the corresponding public key, is included with each commit.
Although at the time of writing no data is being signed.

## Blobs, Tree vs. Filesystems
In Git, regular files are stored as blob type objects.
Trees are stord as tree type objects.
Trees can refer to blobs and other trees by hash.

In Got, there is not two separate types for file objects.
The entire filesystem is tracked as a single data structure, which internally manages a tree of refrences to various peaces of the filesystem.
The data structure supports efficient edits proportional to the number of layers being merged in a given edit.
