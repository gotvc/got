# Got for the Git Familiar

This article assumes knowledge of Git.
If you know what Git is, then Got is the same kind of thing, except it's designed from the ground up to: 
1. Store and version large files and directories
2. Encrypt all data, so that it can it be stored securely on remote devices.

Got is not designed to be used primarily for software development.
You should just use Git for that.
It is designed to be used by power users instead of something like Google Drive or Dropbox.
It also probably works well as a backup or syncing solution, if precise versioning across the entire filesystem is important.

Git is excellent version control software.
For its minimal complexity, its core design is close to the pareto frontier.
Files, and directories are modeled as plainly as possible.
Commits form a directed graph.
All the formats are straightforward and easy to parse; lots of spaces, newlines, and tasteful use of NULL bytes and inline binary.
Most criticism of Git is instead directed towards its user interface (the porcelain), which been historically confusing.
Although it has been slowly improving, it is held back by backwards compatibility.
Got avoids reinventing the wheel where possible.
The main goal is to replace Git's blobs and trees, with something more scalable.
There have also been some small changes to porcelain-level concepts from Git.

## Similar Models

Got's model of version control is heavily inspired by Git.
There are many concepts taken, or adapted from Git, their provenances are listed below.

``` 
Git                  | Got     
---------------------------------------------
Repository           | Repository (Repo)
Remotes              | Spaces
Worktrees            | Working Copies (WC)
Refs, Branches, Tags | Bookmarks (Marks)
Commits              | Snapshots (Snaps)
Blobs, Trees         | Filesystems
```

## Refs, Branches, Tags vs. Marks, Snapshots
In Git, there is a very general idea of a reference, which includes hashes of objects, names for hashes of objects, and names of names.
Git's `HEAD` (taken from the common name for the double-pointer used in linked lists) is therefore a name of a name of a hash of an object, or a ref of a ref of a ref.

In Got, Marks are named pointers to Snapshots.
Marks have names which are unique for the Space that contains them.
Each Repo has a default Space with locally saved content.
Each WC has a HEAD configuration parameter, which contains the name of a mark in the local namespace.
That is the only place in Got where that level of indirection to Snapshots is needed, and it is therefore implemented as a one-off in the WC.

## Remotes vs. Spaces
In both Git and Got, these concepts are containers for refs.
In both, sync operations can be performed between two instances.
Only Got allows syncing operations to be performed between two external Spaces, without requiring that the data be persisted locally.
Got also considers the local set of marks to be a Space, identified by the empty string.

Spaces in Got are always encrypted.
The encryption key is stored in the Repo's configuration.
This means that you can use a remote Blobcache to host a Got Space, and unless you reveal the encryption key, the server has no way of reading any of the data, including Mark names.

## Git vs. Got Identities
I know that Git makes it possible to sign things with some other piece of software.
I only know that exists because GitHub tells me about it.
I don't know what Git uses to sign the Commits (or the Tags?), other than that it may have some of the letters P, G, S, and or H in its name.

Got generates private signing keys automatically and stores them in each Repo.
An identifier, derived from the corresponding public key, is included with each commit.
Although at the time of writing no data is being signed.

## Blobs, Tree vs. Filesystems
In Git, regular files are stored as blob type objects.
Trees are stored as tree type objects.
Trees can refer to blobs and other trees by hash.

In Got, there is not two separate types for filesystem objects.
The entire filesystem is tracked as a single data structure, which cannot be further broken up.
Internally, it manages a tree of references to various pieces of the filesystem.
The data structure supports efficient edits with complexity proportional to the number of contiguous segments being merged in a given edit.
