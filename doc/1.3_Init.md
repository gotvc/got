# Getting Started

To get started using Got all you have to is go to a directory that you want to turn into a Got [Repo](./2.1_Repo.md) & [Working Copy](./2.2_Working_Copy.md), and then run:
```shell
$ got init
using in-process blobcache
successfully initialized got repo in current directory
```

This will create a subdirectory `.got` and 2 configuration files.
- `.got/config` the [Repo](./2.1_Repo.md) configuration file.
  The existence of this file means the directory is a Repo.
- `.got/wc-config` the [Working Copy](./2.2_Working_Copy.md) configuration file.
  The existence of this file means the director is also a Working Copy.

It will also create some other files, which we won't worry about for now.
By default, Got will store your data in the `.got` directory, so you shouldn't delete or modify any of these files, as that could corrupt the repository.

Now you should be able to run `got status`.
```
$ got status
HEAD: master
STAGED:
NOT STAGED:
```

This is saying that the working copy is going to make changes to a Mark called `master`.
There is nothing staged.
And there are no files in the directory that Got can see, but has yet to import.

If you were to run:
``` 
$ touch myfile.txt
```

And then `got status` again.
```
$ got status
HEAD: master
STAGED:
NOT STAGED:
    myfile.txt
```

Now we can see that the file we just created has been noticed by got, but is not yet staged.
Next lets add it to the stage.

```
$ got add myfile.txt
[53ms]  blobs_in=(1blobs Δ=1blobs/s), data_in=(26B Δ=13.68KB/s)
```
As you can see, got tells us about how the import is going.
For larger files you will see multiple threads working to import the file and the status of each of those concurrent imports.

Now print the status again
```
$ got status

HEAD: master
STAGED:
    CREATE myfile.txt
NOT STAGED:
```

Got is telling us that, if we were to commit the changes into a Snapshot, we would be creating a new file called "myfile.txt"

Let's go ahead and commit and see what happens.
```
$ got commit
```

The commit was successful, now let's check on what we just did in 2 ways.
First lets look at the history.
This will open up a nicely formatted view of the history in your pager (usually `less`).
You can usually quit by pressing the `q` key.

```
$ got log

#0000   7VHDkN79AOlQPt_O_82i5kwwLWrxB_b157Ra3sWE7zN
FS: f2GpAom310PLtxx7KDV0-vsH0Nvzji1Og2n1NMqemYJ
Parents: (none)
Created At: 2026-01-25 15:46:39 -0500 EST
Created By: P3w7Ha8w5p0SremkqqC_l_1GX-5z-e8MgtUfCAKWx6k
{
  "authors": [
    "P3w7Ha8w5p0SremkqqC_l_1GX-5z-e8MgtUfCAKWx6k"
  ],
  "authored_at": 4611686020196761940
}
```

This tells us some information about the snapshot that we just created.
1. The Snapshot number (or critical distance to the sinks) is 0.
That is because this Snapshot is the first one in this history, and has no parents.
2. The Snapshot ID is `7VHDkN79AOlQPt_O_82i5kwwLWrxB_b157Ra3sWE7zN`; yours will be different.
3. The hash of the filesystem root is `f2GpAom310PLtxx7KDV0-vsH0Nvzji1Og2n1NMqemYJ`; yours will be different.
4. The Snapshot has no parents
5. When the Snapshot was created, this is always displayed in the local timezone.
6. The ID of the user that created the Snapshot
7. Everything else is arbitrary metadata, it is stored as JSON in the Snapshot.

The next way to look at what we have done is to list the files in the filesystem.

```
$ got ls
-rw-r--r-- myfile.txt
```

The filesystem committed in the most recent Snapshot, which the Mark `master` points to, contains a single file, called `myfile.txt`.
